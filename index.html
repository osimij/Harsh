<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Harsh - Logo Designer & Brand Systems Creator. Joy by origin, rough by translation.">
    <meta name="theme-color" content="#111111">

    <link rel="icon" type="image/svg+xml" href="favicon.svg">

    <!-- Preload critical assets -->
    <link rel="preload" href="assets/hero/profile.jpg" as="image">

    <title>Harsh - Logo & Brand Designer</title>
    <link rel="stylesheet" href="hero.css">
</head>
<body>
    <!-- Splash Screen Overlay -->
    <div class="splash-screen" aria-hidden="true">
        <div class="splash-content">
            <img
                class="splash-image"
                src="assets/hero/profile.jpg"
                alt=""
                width="294"
                height="294"
            >
            <div class="splash-text">
                <p class="splash-line">Greetings, my name is Harsh.</p>
                <p class="splash-line">In Sanskrit, it means Joy.</p>
                <p class="splash-line">Joy by origin, Rough by translation.</p>
                <p class="splash-line">I design logos and brand systems</p>
            </div>
        </div>
    </div>

    <section class="hero" aria-label="Introduction">
        <div class="main">
            <!-- Left Column: Introduction & Navigation -->
            <div class="content">
                <nav class="nav" aria-label="Primary navigation">
                    <div class="nav-left">
                        <a href="contact.html" class="nav-item">Contact</a>
                        <a href="work.html" class="nav-item">See All Work</a>
                    </div>
                </nav>

                <header class="intro-section">
                    <figure class="profile-image">
                        <img
                            src="assets/hero/profile.jpg"
                            alt="Portrait of Harsh"
                            width="66"
                            height="66"
                            loading="eager"
                        >
                    </figure>
                    <div class="intro-text">
                        <p class="intro-line">
                            <span class="text-regular">My mom named me </span><span class="text-medium">Harsh</span><span class="text-regular">.</span>
                        </p>
                        <p class="intro-line">
                            <span class="text-regular">In Sanskrit, it means Joy.</span>
                        </p>
                        <p class="intro-line">
                            <span class="text-regular">Joy by origin, Rough</span><br>
                            <span class="text-regular">by translation.</span>
                        </p>
                        <p class="intro-line">
                            <span class="text-regular">I design logos and brand systems</span>
                        </p>
                    </div>
                </header>
            </div>

            <!-- Right Column: Logo Showcase -->
            <div class="logos-section">
                <div class="main-logo" aria-label="Featured logo artwork">
                    <canvas id="particle-canvas"></canvas>
                </div>

                <div class="logo-grid" role="list" aria-label="Logo portfolio">
                </div>
                <div id="page-announce" class="sr-only" aria-live="polite" aria-atomic="true"></div>
            </div>
        </div>
    </section>

    <script type="module">
        /**
         * Hero Section - Interactive Logo Gallery with GPU Fluid Particle Animation
         * Features:
         * - GPU-accelerated particle simulation with curl noise & vortices
         * - Paged 3x2 logo grid with blur transitions between pages
         * - Auto-cycling synchronized with grid
         * - Click/tap to select
         * - Keyboard navigation
         * - Pause on interaction
         */
        import { GPUParticleSim } from './js/gpu-particle-sim.js';
        import { RasterPointSampler } from './js/raster-point-sampler.js';
        import { Renderer } from './js/renderer.js';

        (async function() {
            'use strict';

            /**
             * Detect display quality and return appropriate particle color.
             */
            function detectParticleColor() {
                const darkGray = '#696968';
                const lightGray = '#a0a09f';

                const hasHDR = window.matchMedia('(dynamic-range: high)').matches;
                const hasWideGamut = window.matchMedia('(color-gamut: p3)').matches ||
                                     window.matchMedia('(color-gamut: rec2020)').matches;
                const hasHighDPR = window.devicePixelRatio >= 2;
                const prefersMoreContrast = window.matchMedia('(prefers-contrast: more)').matches;

                if (prefersMoreContrast) return lightGray;

                const isHighQualityDisplay = hasHDR || (hasWideGamut && hasHighDPR);
                return isHighQualityDisplay ? darkGray : lightGray;
            }

            // Configuration (synced with particle-settings.json)
            const CONFIG = {
                cycleInterval: 5000,
                morphDuration: 2500,
                holdDuration: 2500,
                pauseDuration: 10000,
                initialDelay: 500,
                initialActive: 2,
                particleCount: 350000,
                particleSize: 1.2,
                particleColor: '#ffffff',
                glowIntensity: 0.4,
                depthVariance: 0.5,
                zoom: 1.25,
                sizeRandom: 1.0,
                opacityRandom: 1.0,
                sizeMin: 0.8,
                sizeMax: 1.2,
                opacityMin: 0.4,
                opacityMax: 1.0,
                squaresEnabled: true,
                squareRatio: 0.25,
                colorMode: 'chromatic',
                chromaticShift: 0.07,
                gradientOverlayEnabled: false,
                gradientColorA: '#00d4ff',
                gradientColorB: '#a855f7',
                gradientStrength: 0.7,
                gradientDirection: 'diag'
            };

            function isHexColor(value) {
                return typeof value === 'string' && /^#(?:[0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test(value.trim());
            }

            function applyMainParticleSettings(raw) {
                if (!raw || typeof raw !== 'object') return;

                const num = (v, fallback) => {
                    const n = Number(v);
                    return Number.isFinite(n) ? n : fallback;
                };
                const clamp01 = (v, fallback) => {
                    const n = num(v, fallback);
                    return Math.max(0, Math.min(1, n));
                };

                // Density keys from Particle Forge config
                if (raw.logoDensity != null || raw.density != null) {
                    CONFIG.particleCount = Math.max(1000, Math.round(num(raw.logoDensity ?? raw.density, CONFIG.particleCount)));
                }

                if (raw.size != null) CONFIG.particleSize = Math.max(0.1, num(raw.size, CONFIG.particleSize));
                if (raw.glowIntensity != null) CONFIG.glowIntensity = clamp01(raw.glowIntensity, CONFIG.glowIntensity);
                if (raw.depthVariance != null) CONFIG.depthVariance = Math.max(0, num(raw.depthVariance, CONFIG.depthVariance));
                if (raw.zoom != null) CONFIG.zoom = Math.max(0.1, num(raw.zoom, CONFIG.zoom));
                if (raw.sizeRandom != null) CONFIG.sizeRandom = clamp01(raw.sizeRandom, CONFIG.sizeRandom);
                if (raw.opacityRandom != null) CONFIG.opacityRandom = clamp01(raw.opacityRandom, CONFIG.opacityRandom);
                if (raw.sizeMin != null) CONFIG.sizeMin = Math.max(0.05, num(raw.sizeMin, CONFIG.sizeMin));
                if (raw.sizeMax != null) CONFIG.sizeMax = Math.max(0.05, num(raw.sizeMax, CONFIG.sizeMax));
                if (raw.opacityMin != null) CONFIG.opacityMin = clamp01(raw.opacityMin, CONFIG.opacityMin);
                if (raw.opacityMax != null) CONFIG.opacityMax = clamp01(raw.opacityMax, CONFIG.opacityMax);
                if (raw.squaresEnabled != null) CONFIG.squaresEnabled = !!raw.squaresEnabled;
                if (raw.squareRatio != null) CONFIG.squareRatio = clamp01(raw.squareRatio, CONFIG.squareRatio);
                if (raw.chromaticShift != null) CONFIG.chromaticShift = Math.max(0, num(raw.chromaticShift, CONFIG.chromaticShift));

                if (typeof raw.gradientOverlayEnabled === 'boolean') CONFIG.gradientOverlayEnabled = raw.gradientOverlayEnabled;
                if (isHexColor(raw.gradientColorA)) CONFIG.gradientColorA = raw.gradientColorA;
                if (isHexColor(raw.gradientColorB)) CONFIG.gradientColorB = raw.gradientColorB;
                if (raw.gradientStrength != null) CONFIG.gradientStrength = clamp01(raw.gradientStrength, CONFIG.gradientStrength);
                if (typeof raw.gradientDirection === 'string') CONFIG.gradientDirection = raw.gradientDirection;

                if (isHexColor(raw.particleColor)) CONFIG.particleColor = raw.particleColor;

                if (typeof raw.colorMode === 'string') {
                    const mode = raw.colorMode.trim();
                    if (isHexColor(mode)) {
                        // Particle Forge stores solid color choices in colorMode as hex.
                        CONFIG.particleColor = mode;
                    } else if (mode) {
                        CONFIG.colorMode = mode;
                    }
                }
            }

            async function loadMainSettingsFile() {
                try {
                    const res = await fetch('./particle-settings.json', { cache: 'no-store' });
                    if (!res.ok) return;
                    const json = await res.json();
                    applyMainParticleSettings(json);
                } catch (_err) {
                    // Optional file; keep defaults when unavailable.
                }
            }

            // Paging constants
            const LOGOS_PER_PAGE = 6;

            // State — global index tracks position across ALL logos
            let globalIndex = CONFIG.initialActive;
            let nextGlobalIndex = null;
            let currentPage = 0;
            let isPageTransitioning = false;

            let cycleTimer = null;
            let pauseTimer = null;
            let isPaused = false;
            let isTransitioning = false;
            let transitionStartTime = 0;

            // GPU Particle system components
            let gpuSim = null;
            let rasterSampler = null;
            let renderer = null;
            let gl = null;
            let targetTextures = [];
            let animationId = null;
            let lastTime = 0;

            // Logo data loaded from manifest
            let logoManifest = [];
            let svgStrings = [];

            // DOM Elements
            const hero = document.querySelector('.hero');
            const canvas = document.getElementById('particle-canvas');
            const logoGrid = document.querySelector('.logo-grid');
            const pageAnnounce = document.getElementById('page-announce');
            let cells = [];
            let totalLogos = 0;

            // Check for reduced motion preference
            const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

            // ── Paging helpers ──────────────────────────

            function totalPages() {
                return Math.ceil(totalLogos / LOGOS_PER_PAGE);
            }

            /** Which page does global index `gi` fall on? */
            function pageOf(gi) {
                return Math.floor(gi / LOGOS_PER_PAGE);
            }

            /** Which cell (0-5) within its page does `gi` map to? */
            function cellOf(gi) {
                return gi % LOGOS_PER_PAGE;
            }

            /** Global index from page + cell */
            function globalOf(page, cell) {
                return page * LOGOS_PER_PAGE + cell;
            }

            /** How many logos does page `p` show? Always 6 (wraps around manifest). */
            function logosOnPage(p) {
                return LOGOS_PER_PAGE;
            }

            /**
             * Find the next global index (starting at `startGi`) that has a valid GPU target texture.
             * Returns null when no usable textures exist.
             */
            function findNextRenderableGlobalIndex(startGi) {
                if (!totalLogos || !targetTextures.length) return null;

                for (let offset = 0; offset < totalLogos; offset++) {
                    const gi = startGi + offset;
                    const texIdx = ((gi % totalLogos) + totalLogos) % totalLogos;
                    if (targetTextures[texIdx]) return gi;
                }

                return null;
            }

            // ── Logo loading ────────────────────────────

            async function loadLogos() {
                const manifestRes = await fetch('assets/logos/logos.json');
                if (!manifestRes.ok) throw new Error(`Failed to load logo manifest (${manifestRes.status})`);
                const manifest = await manifestRes.json();
                logoManifest = manifest.logos;

                const activeIdx = logoManifest.findIndex(l => l.initialActive);
                if (activeIdx !== -1) {
                    CONFIG.initialActive = activeIdx;
                    globalIndex = activeIdx;
                }

                const fetches = logoManifest.map(logo =>
                    fetch(`assets/logos/${logo.file}`).then(r => {
                        if (!r.ok) throw new Error(`Failed to load ${logo.file}`);
                        return r.text();
                    })
                );
                svgStrings = await Promise.all(fetches);
                totalLogos = logoManifest.length;
            }

            function deduplicateSvgIds(svgString, prefix) {
                return svgString.replace(/\bid="([^"]+)"/g, `id="${prefix}_$1"`)
                                .replace(/url\(#([^)]+)\)/g, `url(#${prefix}_$1)`)
                                .replace(/#clip(\d)/g, `#${prefix}_clip$1`);
            }

            // ── Grid building (paged) ───────────────────

            /**
             * Build the logo grid for a specific page.
             * Always renders LOGOS_PER_PAGE cells; wraps around the manifest for partial pages.
             */
            function buildLogoGrid(page) {
                currentPage = page;
                logoGrid.innerHTML = '';

                const activeCellIdx = cellOf(globalIndex);

                for (let cell = 0; cell < LOGOS_PER_PAGE; cell++) {
                    const gi = globalOf(page, cell);
                    const wrappedIdx = gi % totalLogos;
                    const logo = logoManifest[wrappedIdx];
                    const isActive = (cell === activeCellIdx && pageOf(globalIndex) === page);

                    const btn = document.createElement('button');
                    btn.className = 'logo-cell' + (isActive ? ' logo-cell-active' : '');
                    btn.setAttribute('role', 'listitem');
                    btn.setAttribute('data-logo', logo.id);
                    btn.setAttribute('data-global-index', String(gi));
                    btn.setAttribute('aria-label', `View ${logo.name} logo`);
                    btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
                    btn.setAttribute('tabindex', '0');

                    let thumbSvg = deduplicateSvgIds(svgStrings[wrappedIdx], `logo_${logo.id}_p${page}_c${cell}`);
                    thumbSvg = thumbSvg.replace(/fill="#111111"/g, 'fill="currentColor"');

                    const wrapper = document.createElement('div');
                    wrapper.className = 'logo-wrapper';
                    wrapper.innerHTML = thumbSvg;

                    const svgEl = wrapper.querySelector('svg');
                    if (svgEl) {
                        svgEl.classList.add('logo-img');
                        svgEl.setAttribute('aria-hidden', 'true');
                    }

                    btn.appendChild(wrapper);
                    logoGrid.appendChild(btn);
                }

                cells = Array.from(logoGrid.querySelectorAll('.logo-cell'));

                cells.forEach(cell => {
                    cell.addEventListener('click', handleCellClick);
                    cell.addEventListener('keydown', handleKeyDown);
                });
            }

            // ── GPU particle system ─────────────────────

            async function initParticleSystem() {
                const container = canvas.parentElement;
                let rect = container.getBoundingClientRect();
                if (rect.width === 0 || rect.height === 0) {
                    await new Promise(resolve => requestAnimationFrame(resolve));
                    rect = container.getBoundingClientRect();
                }

                const dpr = Math.min(window.devicePixelRatio || 1, 2);
                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;

                renderer = new Renderer(canvas);
                if (!renderer.gl) {
                    console.error('WebGL2 not supported');
                    return;
                }

                gl = renderer.gl;

                renderer.settings.glowIntensity = CONFIG.glowIntensity;
                renderer.settings.depthVariance = CONFIG.depthVariance;
                renderer.settings.zoom = CONFIG.zoom;
                renderer.settings.userSize = CONFIG.particleSize;
                renderer.settings.useColorOverride = true;
                const hexToRgb = (hex) => {
                    const h = hex.replace('#', '');
                    return [
                        parseInt(h.substring(0, 2), 16) / 255,
                        parseInt(h.substring(2, 4), 16) / 255,
                        parseInt(h.substring(4, 6), 16) / 255
                    ];
                };
                renderer.settings.colorOverrideRgb = hexToRgb(CONFIG.particleColor);
                renderer.settings.sizeRandom = CONFIG.sizeRandom;
                renderer.settings.opacityRandom = CONFIG.opacityRandom;
                renderer.settings.sizeMin = CONFIG.sizeMin;
                renderer.settings.sizeMax = CONFIG.sizeMax;
                renderer.settings.opacityMin = CONFIG.opacityMin;
                renderer.settings.opacityMax = CONFIG.opacityMax;
                renderer.settings.squaresEnabled = CONFIG.squaresEnabled;
                renderer.settings.squareRatio = CONFIG.squareRatio;
                renderer.settings.colorMode = CONFIG.colorMode;
                renderer.settings.chromaticShift = CONFIG.chromaticShift;
                renderer.settings.gradientOverlayEnabled = CONFIG.gradientOverlayEnabled;
                renderer.settings.gradientColorA = CONFIG.gradientColorA;
                renderer.settings.gradientColorB = CONFIG.gradientColorB;
                renderer.settings.gradientStrength = CONFIG.gradientStrength;
                renderer.settings.gradientDirection = CONFIG.gradientDirection;

                try {
                    gpuSim = new GPUParticleSim(gl, { count: CONFIG.particleCount, seed: 42 });
                } catch (e) {
                    console.error('GPU particle sim not supported:', e);
                    return;
                }

                rasterSampler = new RasterPointSampler();

                for (const svgString of svgStrings) {
                    try {
                        const { texture } = await rasterSampler.sampleToTexture(
                            gl, svgString, CONFIG.particleCount,
                            { rasterSize: 1024, edgeRatio: 0.5 }
                        );
                        targetTextures.push(texture);
                    } catch (e) {
                        console.error('Failed to sample SVG to texture:', e);
                        targetTextures.push(null);
                    }
                }

                const initialGi = findNextRenderableGlobalIndex(globalIndex);
                if (initialGi !== null) {
                    globalIndex = initialGi;
                    nextGlobalIndex = null;

                    const initialTex = targetTextures[initialGi % totalLogos];
                    gpuSim.setTargets({ fromTex: initialTex, toTex: initialTex });
                    setActiveLogo(globalIndex, true);
                }

                window.addEventListener('resize', handleResize);
                startAnimationLoop();
            }

            function handleResize() {
                if (!canvas || !renderer) return;
                const container = canvas.parentElement;
                const rect = container.getBoundingClientRect();
                const dpr = Math.min(window.devicePixelRatio || 1, 2);
                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;
            }

            // ── Animation loop ──────────────────────────

            function startAnimationLoop() {
                lastTime = performance.now();

                function animate(currentTime) {
                    const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.05);
                    lastTime = currentTime;

                    let morphT = 1, scatterT = 0, chaosT = 0, attractT = 1, settleT = 1;

                    if (isTransitioning) {
                        const elapsed = currentTime - transitionStartTime;
                        const progress = Math.min(elapsed / CONFIG.morphDuration, 1);
                        const easedProgress = easeInOutCubic(progress);

                        morphT = easedProgress;
                        scatterT = Math.sin(progress * Math.PI) * 0.4;
                        chaosT = Math.sin(progress * Math.PI) * 0.6;
                        attractT = easedProgress;
                        settleT = progress * progress;

                        if (progress >= 1) {
                            const texIdx = nextGlobalIndex % totalLogos;
                            const toTex = targetTextures[texIdx];
                            if (toTex) {
                                gpuSim.setTargets({ fromTex: toTex, toTex: toTex });
                            }
                            globalIndex = nextGlobalIndex;
                            isTransitioning = false;
                        }
                    }

                    gpuSim.step(deltaTime, {
                        morphT, scatterT, chaosT, attractT, settleT,
                        noiseScale: 3.5, noiseStrength: 0.9, noiseSpeed: 0.2,
                        vortexStrength: 1.5, vortexRadius: 0.7,
                        vortex1: [0.0, 0.0], vortex2: [-0.25, 0.2], vortex3: [0.3, -0.15],
                        repulseStrength: 1.2, attractStrength: 2.8,
                        drag: 1.2, maxSpeed: 2.5
                    });

                    const curTexIdx = globalIndex % totalLogos;
                    const nextTexIdx = nextGlobalIndex !== null ? (nextGlobalIndex % totalLogos) : curTexIdx;

                    renderer.renderGPU({
                        count: gpuSim.count,
                        texWidth: gpuSim.texWidth,
                        texHeight: gpuSim.texHeight,
                        posTex: gpuSim.getPositionTexture(),
                        velTex: gpuSim.getVelocityTexture(),
                        randTex: gpuSim.getRandomTexture(),
                        targetFromTex: targetTextures[curTexIdx],
                        targetToTex: targetTextures[nextTexIdx]
                    });

                    animationId = requestAnimationFrame(animate);
                }

                animationId = requestAnimationFrame(animate);
            }

            function easeInOutCubic(t) {
                return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
            }

            // ── Morph & activation ──────────────────────

            function morphToLogo(gi) {
                const texIdx = gi % totalLogos;
                if (!gpuSim || !targetTextures[texIdx]) return;

                const fromTexIdx = globalIndex % totalLogos;
                const fromTex = targetTextures[fromTexIdx];
                const toTex = targetTextures[texIdx];

                if (fromTex && toTex) {
                    gpuSim.setTargets({ fromTex, toTex });
                }

                nextGlobalIndex = gi;
                isTransitioning = true;
                transitionStartTime = performance.now();
            }

            /**
             * Set active logo by global index.
             * Highlights the correct cell on the current page.
             */
            function setActiveLogo(gi, skipMorph = false) {
                const cellIdx = cellOf(gi);

                cells.forEach((cell, i) => {
                    const isActive = (i === cellIdx);
                    cell.classList.toggle('logo-cell-active', isActive);
                    cell.setAttribute('aria-pressed', isActive ? 'true' : 'false');
                });

                if (!skipMorph && gi !== globalIndex) {
                    morphToLogo(gi);
                } else if (skipMorph) {
                    globalIndex = gi;
                }
            }

            // ── Paging transitions ──────────────────────

            /**
             * Cycle to the next logo. If we've reached the end of the current page,
             * trigger a page transition instead.
             */
            function cycleToNext() {
                if (isPaused || isTransitioning || isPageTransitioning) return;

                const nextGi = findNextRenderableGlobalIndex(globalIndex + 1);
                if (nextGi === null || nextGi === globalIndex) return;

                const nextPage = pageOf(nextGi);

                if (nextPage !== currentPage) {
                    // We've cycled through all cells on this page — transition to next page
                    const destinationPage = nextPage % totalPages();
                    transitionToPage(destinationPage);
                } else {
                    setActiveLogo(nextGi);
                }
            }

            /**
             * Simultaneous crossfade using a body-level clone.
             * The clone is placed in document.body with position:fixed so it is
             * completely isolated from .logo-grid's CSS cascade and layout.
             */
            function transitionToPage(newPage) {
                isPageTransitioning = true;
                stopCycling();
                logoGrid.setAttribute('aria-busy', 'true');

                const transitionMs = prefersReducedMotion ? 10 : 1000;

                // Step 1: Snapshot the grid's viewport position
                const rect = logoGrid.getBoundingClientRect();

                // Step 2: Deep-clone the grid and restyle as a fixed overlay
                const clone = logoGrid.cloneNode(true);
                clone.className = 'crossfade-clone';
                clone.removeAttribute('role');
                clone.removeAttribute('aria-label');
                clone.setAttribute('aria-hidden', 'true');
                clone.style.top = rect.top + 'px';
                clone.style.left = rect.left + 'px';
                clone.style.width = rect.width + 'px';
                clone.style.height = rect.height + 'px';
                // Step 3: Append clone to body (completely outside .logo-grid)
                document.body.appendChild(clone);

                // Step 4: Rebuild the real grid with new page content
                const firstGi = globalOf(newPage, 0);
                buildLogoGrid(newPage);

                // Step 5: Set new grid cells to hidden (blur-in start state)
                logoGrid.classList.add('page-enter');

                // Force reflow so browser registers initial hidden state
                void logoGrid.offsetHeight;

                // Step 6: Simultaneously fade out clone + blur in new grid
                logoGrid.classList.remove('page-enter');
                logoGrid.classList.add('page-enter-active');
                clone.classList.add('fade-out');

                // Step 7: Cleanup after transition completes
                setTimeout(() => {
                    logoGrid.classList.remove('page-enter-active');
                    if (clone.parentNode) clone.parentNode.removeChild(clone);
                    logoGrid.setAttribute('aria-busy', 'false');
                    isPageTransitioning = false;

                    // Morph particles to the first logo on the new page
                    setActiveLogo(firstGi);

                    // Announce page change for screen readers
                    const pageNum = newPage + 1;
                    const firstName = logoManifest[firstGi % totalLogos].name;
                    pageAnnounce.textContent = `Page ${pageNum} of ${totalPages()}, showing ${firstName}`;

                    // Resume auto-cycling
                    if (!isPaused) {
                        startCycling();
                    }
                }, transitionMs);
            }

            // ── Cycling controls ────────────────────────

            function startCycling() {
                if (prefersReducedMotion) return;
                stopCycling();
                cycleTimer = setInterval(cycleToNext, CONFIG.cycleInterval);
            }

            function stopCycling() {
                if (cycleTimer) {
                    clearInterval(cycleTimer);
                    cycleTimer = null;
                }
            }

            function pauseCycling() {
                isPaused = true;
                stopCycling();

                if (pauseTimer) clearTimeout(pauseTimer);
                pauseTimer = setTimeout(() => {
                    isPaused = false;
                    startCycling();
                }, CONFIG.pauseDuration);
            }

            // ── Event handlers ──────────────────────────

            function handleCellClick(event) {
                if (isPageTransitioning) return;
                const cell = event.currentTarget;
                const gi = parseInt(cell.getAttribute('data-global-index'), 10);

                if (!isNaN(gi) && gi !== globalIndex && !isTransitioning) {
                    setActiveLogo(gi);
                    pauseCycling();
                }
            }

            function handleKeyDown(event) {
                if (isPageTransitioning) return;
                const cell = event.currentTarget;
                const cellIdx = Array.from(cells).indexOf(cell);
                let newCellIdx = cellIdx;

                switch (event.key) {
                    case 'Enter':
                    case ' ': {
                        event.preventDefault();
                        const gi = parseInt(cell.getAttribute('data-global-index'), 10);
                        if (!isNaN(gi) && gi !== globalIndex && !isTransitioning) {
                            setActiveLogo(gi);
                            pauseCycling();
                        }
                        break;
                    }
                    case 'ArrowRight':
                        event.preventDefault();
                        newCellIdx = (cellIdx + 1) % LOGOS_PER_PAGE;
                        cells[newCellIdx].focus();
                        break;
                    case 'ArrowLeft':
                        event.preventDefault();
                        newCellIdx = (cellIdx - 1 + LOGOS_PER_PAGE) % LOGOS_PER_PAGE;
                        cells[newCellIdx].focus();
                        break;
                    case 'ArrowDown':
                        event.preventDefault();
                        newCellIdx = (cellIdx + 3) % LOGOS_PER_PAGE;
                        cells[newCellIdx].focus();
                        break;
                    case 'ArrowUp':
                        event.preventDefault();
                        newCellIdx = (cellIdx - 3 + LOGOS_PER_PAGE) % LOGOS_PER_PAGE;
                        cells[newCellIdx].focus();
                        break;
                }
            }

            // ── Splash screen orchestration ─────────────

            const splash = document.querySelector('.splash-screen');
            const splashAlreadyShown = sessionStorage.getItem('splashShown') === '1';

            function runSplashSequence() {
                return new Promise(resolve => {
                    setTimeout(() => { splash.classList.add('splash-appear'); }, 300);
                    setTimeout(() => { splash.classList.add('splash-fade'); }, 3000);
                    setTimeout(() => { splash.classList.add('splash-bg-black'); }, 3600);
                    setTimeout(() => { splash.style.display = 'none'; resolve(); }, 4100);
                });
            }

            // ── Initialization ──────────────────────────

            await loadMainSettingsFile();
            await loadLogos();
            currentPage = pageOf(globalIndex);
            buildLogoGrid(currentPage);
            setActiveLogo(globalIndex, true);

            if (splashAlreadyShown) {
                splash.style.display = 'none';
                hero.classList.add('instant');
                await initParticleSystem();
                requestAnimationFrame(() => { hero.classList.add('loaded'); });
            } else {
                await Promise.all([
                    runSplashSequence(),
                    initParticleSystem()
                ]);
                sessionStorage.setItem('splashShown', '1');
                requestAnimationFrame(() => { hero.classList.add('loaded'); });
            }

            if (!prefersReducedMotion) {
                setTimeout(() => {
                    cycleToNext();
                    if (!isPaused && !isPageTransitioning) {
                        startCycling();
                    }
                }, CONFIG.initialDelay);
            }

            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    stopCycling();
                    if (animationId) {
                        cancelAnimationFrame(animationId);
                        animationId = null;
                    }
                } else {
                    if (!animationId) {
                        startAnimationLoop();
                    }
                    if (!isPaused && !isPageTransitioning) {
                        startCycling();
                    }
                }
            });
        })();
    </script>
</body>
</html>
