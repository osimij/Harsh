<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Harsh - Logo Designer & Brand Systems Creator. Joy by origin, rough by translation.">
    <meta name="theme-color" content="#111111">

    <link rel="icon" type="image/svg+xml" href="favicon.svg">

    <!-- Preload critical assets -->
    <link rel="preload" href="assets/hero/profile.jpg" as="image">

    <title>Harsh - Logo & Brand Designer</title>
    <link rel="stylesheet" href="hero.css">
</head>
<body>
    <!-- Splash Screen Overlay -->
    <div class="splash-screen" aria-hidden="true">
        <div class="splash-content">
            <img
                class="splash-image"
                src="assets/hero/profile.jpg"
                alt=""
                width="294"
                height="294"
            >
            <div class="splash-text">
                <p class="splash-line">Greetings, my name is Harsh.</p>
                <p class="splash-line">In Sanskrit, it means Joy.</p>
                <p class="splash-line">Joy by origin, Rough by translation.</p>
                <p class="splash-line">I design logos and brand systems</p>
            </div>
        </div>
    </div>

    <section class="hero" aria-label="Introduction">
        <div class="main">
            <!-- Left Column: Introduction & Navigation -->
            <div class="content">
                <nav class="nav" aria-label="Primary navigation">
                    <div class="nav-left">
                        <a href="contact.html" class="nav-item">Contact</a>
                        <a href="work.html" class="nav-item">All Work</a>
                    </div>
                </nav>

                <header class="intro-section">
                    <figure class="profile-image">
                        <img
                            src="assets/hero/profile.jpg"
                            alt="Portrait of Harsh"
                            width="66"
                            height="66"
                            loading="eager"
                        >
                    </figure>
                    <div class="intro-text">
                        <p class="intro-line">
                            <span class="text-regular">My mom named me </span><span class="text-medium">Harsh</span><span class="text-regular">.</span>
                        </p>
                        <p class="intro-line">
                            <span class="text-regular">In Sanskrit, it means Joy.</span>
                        </p>
                        <p class="intro-line">
                            <span class="text-regular">Joy by origin, Rough</span><br>
                            <span class="text-regular">by translation.</span>
                        </p>
                        <p class="intro-line">
                            <span class="text-regular">I design logos and brand systems</span>
                        </p>
                    </div>
                </header>
            </div>

            <!-- Right Column: Logo Showcase -->
            <div class="logos-section">
                <div class="main-logo" aria-label="Featured logo artwork">
                    <canvas id="particle-canvas"></canvas>
                </div>

                <div class="logo-grid" role="list" aria-label="Logo portfolio">
                </div>
                <div id="page-announce" class="sr-only" aria-live="polite" aria-atomic="true"></div>
            </div>
        </div>

        <nav class="hero-socials" aria-label="Social links">
            <a href="mailto:hello@harshbika.com" aria-label="Email">
                <svg viewBox="1 2.65 24.5 21.2" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill="none" d="M2.20703 6.62836L9.84412 10.9556C12.6596 12.5509 13.8492 12.5509 16.6648 10.9556L24.3018 6.62836" stroke-width="2.14976" stroke-linejoin="round"/><path fill="none" d="M2.22445 14.8869C2.29667 18.2736 2.33278 19.9668 3.58239 21.2213C4.83198 22.4756 6.57112 22.5192 10.0494 22.6066C12.1931 22.6605 14.3157 22.6605 16.4595 22.6066C19.9378 22.5192 21.6768 22.4756 22.9265 21.2213C24.1761 19.9668 24.2122 18.2736 24.2844 14.8869C24.3077 13.798 24.3077 12.7155 24.2844 11.6266C24.2122 8.23997 24.1761 6.54666 22.9265 5.29231C21.6768 4.03795 19.9378 3.99426 16.4595 3.90686C14.3157 3.853 12.1931 3.853 10.0494 3.90685C6.57112 3.99424 4.83198 4.03793 3.58238 5.2923C2.33277 6.54665 2.29667 8.23996 2.22444 11.6266C2.20122 12.7155 2.20123 13.798 2.22445 14.8869Z" stroke-width="2.14976" stroke-linejoin="round"/></svg>
            </a>
            <a href="https://x.com/hrshbika" target="_blank" rel="noopener noreferrer" aria-label="X">
                <svg viewBox="0 0 24 23" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M18.0561 1.81909H21.38L14.1183 9.86732L22.6612 20.8191H15.9721L10.733 14.1769L4.73835 20.8191H1.41242L9.17961 12.2107L0.984375 1.81909H7.84321L12.5789 7.89034L18.0561 1.81909ZM16.8895 18.8899H18.7313L6.84242 3.64699H4.86596L16.8895 18.8899Z"/></svg>
            </a>
            <a href="https://www.instagram.com/bikayaar/" target="_blank" rel="noopener noreferrer" aria-label="Instagram">
                <svg viewBox="0 0 24 23" fill="none" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_428_559)"><path d="M11.8237 2.06467C14.9828 2.06467 15.357 2.0781 16.5994 2.13185C17.754 2.18111 18.3775 2.36922 18.7932 2.52597C19.3428 2.73199 19.74 2.9828 20.1511 3.3814C20.5668 3.78448 20.8208 4.16517 21.0332 4.69813C21.1949 5.10121 21.3889 5.71031 21.4397 6.8255C21.4951 8.03474 21.509 8.39751 21.509 11.4564C21.509 14.5199 21.4951 14.8826 21.4397 16.0874C21.3889 17.2071 21.1949 17.8117 21.0332 18.2148C20.8208 18.7477 20.5621 19.1329 20.1511 19.5315C19.7354 19.9346 19.3428 20.1809 18.7932 20.3869C18.3775 20.5437 17.7494 20.7318 16.5994 20.781C15.3523 20.8348 14.9782 20.8482 11.8237 20.8482C8.66455 20.8482 8.29044 20.8348 7.04803 20.781C5.89337 20.7318 5.26986 20.5437 4.85418 20.3869C4.30456 20.1809 3.90736 19.9301 3.4963 19.5315C3.08063 19.1284 2.8266 18.7477 2.61415 18.2148C2.45249 17.8117 2.25851 17.2026 2.20771 16.0874C2.15228 14.8782 2.13843 14.5154 2.13843 11.4564C2.13843 8.39303 2.15228 8.03026 2.20771 6.8255C2.25851 5.70583 2.45249 5.10121 2.61415 4.69813C2.8266 4.16517 3.08525 3.78 3.4963 3.3814C3.91198 2.97832 4.30456 2.73199 4.85418 2.52597C5.26986 2.36922 5.89799 2.18111 7.04803 2.13185C8.29044 2.0781 8.66455 2.06467 11.8237 2.06467ZM11.8237 0C8.61375 0 8.21193 0.013436 6.95104 0.0671801C5.69477 0.120924 4.83109 0.317986 4.08287 0.600142C3.30232 0.895735 2.64186 1.28538 1.98601 1.92583C1.32555 2.5618 0.923726 3.20225 0.618897 3.95467C0.327923 4.68469 0.124703 5.51773 0.0692795 6.73592C0.0138559 7.96308 0 8.35273 0 11.4654C0 14.5781 0.0138559 14.9677 0.0692795 16.1904C0.124703 17.4086 0.327923 18.2461 0.618897 18.9717C0.923726 19.7286 1.32555 20.369 1.98601 21.005C2.64186 21.641 3.30232 22.0351 4.07825 22.3262C4.83109 22.6083 5.69015 22.8054 6.94642 22.8591C8.20731 22.9129 8.60913 22.9263 11.8191 22.9263C15.029 22.9263 15.4308 22.9129 16.6917 22.8591C17.948 22.8054 18.8117 22.6083 19.5599 22.3262C20.3358 22.0351 20.9963 21.641 21.6521 21.005C22.308 20.369 22.7144 19.7286 23.0146 18.9761C23.3056 18.2461 23.5088 17.4131 23.5643 16.1949C23.6197 14.9722 23.6335 14.5826 23.6335 11.4699C23.6335 8.35721 23.6197 7.96756 23.5643 6.74488C23.5088 5.52668 23.3056 4.68917 23.0146 3.96363C22.7237 3.20225 22.3218 2.5618 21.6614 1.92583C21.0055 1.28986 20.3451 0.895735 19.5691 0.604621C18.8163 0.322464 17.9572 0.125403 16.701 0.0716588C15.4355 0.013436 15.0336 0 11.8237 0Z"/><path d="M11.8235 5.57595C8.47037 5.57595 5.75 8.21389 5.75 11.4654C5.75 14.7169 8.47037 17.3549 11.8235 17.3549C15.1766 17.3549 17.897 14.7169 17.897 11.4654C17.897 8.21389 15.1766 5.57595 11.8235 5.57595ZM11.8235 15.2857C9.64813 15.2857 7.88381 13.5749 7.88381 11.4654C7.88381 9.35595 9.64813 7.6451 11.8235 7.6451C13.9989 7.6451 15.7632 9.35595 15.7632 11.4654C15.7632 13.5749 13.9989 15.2857 11.8235 15.2857Z"/><path d="M19.5546 5.34302C19.5546 6.10439 18.9172 6.71797 18.1367 6.71797C17.3515 6.71797 16.7188 6.09991 16.7188 5.34302C16.7188 4.58164 17.3561 3.96806 18.1367 3.96806C18.9172 3.96806 19.5546 4.58612 19.5546 5.34302Z"/></g><defs><clipPath id="clip0_428_559"><rect width="23.6474" height="22.9308" fill="white"/></clipPath></defs></svg>
            </a>
            <a href="https://www.linkedin.com/in/hrshbika/" target="_blank" rel="noopener noreferrer" aria-label="LinkedIn">
                <svg viewBox="0 0 24 23" fill="none" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_428_560)"><path d="M21.8969 0H1.74584C0.780549 0 0 0.738981 0 1.65263V21.2737C0 22.1873 0.780549 22.9308 1.74584 22.9308H21.8969C22.8622 22.9308 23.6474 22.1873 23.6474 21.2782V1.65263C23.6474 0.738981 22.8622 0 21.8969 0ZM7.0157 19.5404H3.50554V8.59457H7.0157V19.5404ZM5.26062 7.10318C4.13368 7.10318 3.22381 6.22088 3.22381 5.13256C3.22381 4.04424 4.13368 3.16194 5.26062 3.16194C6.38295 3.16194 7.29282 4.04424 7.29282 5.13256C7.29282 6.2164 6.38295 7.10318 5.26062 7.10318ZM20.1511 19.5404H16.6455V14.2198C16.6455 12.9523 16.6225 11.3176 14.8212 11.3176C12.9968 11.3176 12.7197 12.7015 12.7197 14.1302V19.5404H9.21879V8.59457H12.5812V10.0905H12.6273C13.0938 9.23055 14.2392 8.32137 15.9435 8.32137C19.4952 8.32137 20.1511 10.5876 20.1511 13.5346V19.5404Z"/></g><defs><clipPath id="clip0_428_560"><rect width="23.6474" height="22.9308" fill="white"/></clipPath></defs></svg>
            </a>
        </nav>
    </section>

    <script type="module">
        /**
         * Hero Section - Interactive Logo Gallery with GPU Fluid Particle Animation
         * Features:
         * - GPU-accelerated particle simulation with curl noise & vortices
         * - Paged 3x2 logo grid with blur transitions between pages
         * - Auto-cycling synchronized with grid
         * - Click/tap to select
         * - Keyboard navigation
         * - Pause on interaction
         */
        import { GPUParticleSim } from './js/gpu-particle-sim.js';
        import { RasterPointSampler } from './js/raster-point-sampler.js';
        import { Renderer } from './js/renderer.js';

        (async function() {
            'use strict';

            /**
             * Detect display quality and return appropriate particle color.
             */
            function detectParticleColor() {
                const darkGray = '#696968';
                const lightGray = '#a0a09f';

                const hasHDR = window.matchMedia('(dynamic-range: high)').matches;
                const hasWideGamut = window.matchMedia('(color-gamut: p3)').matches ||
                                     window.matchMedia('(color-gamut: rec2020)').matches;
                const hasHighDPR = window.devicePixelRatio >= 2;
                const prefersMoreContrast = window.matchMedia('(prefers-contrast: more)').matches;

                if (prefersMoreContrast) return lightGray;

                const isHighQualityDisplay = hasHDR || (hasWideGamut && hasHighDPR);
                return isHighQualityDisplay ? darkGray : lightGray;
            }

            // Configuration (synced with particle-settings.json)
            const CONFIG = {
                cycleInterval: 5000,
                morphDuration: 2500,
                holdDuration: 2500,
                pauseDuration: 10000,
                initialDelay: 500,
                initialActive: 2,
                particleCount: 350000,
                particleSize: 1.2,
                particleColor: '#ffffff',
                glowIntensity: 0.4,
                depthVariance: 0.5,
                zoom: 1.25,
                sizeRandom: 1.0,
                opacityRandom: 1.0,
                sizeMin: 0.8,
                sizeMax: 1.2,
                opacityMin: 0.4,
                opacityMax: 1.0,
                squaresEnabled: true,
                squareRatio: 0.25,
                colorMode: 'chromatic',
                chromaticShift: 0.07,
                gradientOverlayEnabled: false,
                gradientColorA: '#00d4ff',
                gradientColorB: '#a855f7',
                gradientStrength: 0.7,
                gradientDirection: 'diag'
            };
            const PHONE_PARTICLE_COUNT = 170000;
            const PHONE_PARTICLE_SIZE = 1.3;
            const PHONE_PARTICLE_QUERY = '(max-width: 767px)';

            function isHexColor(value) {
                return typeof value === 'string' && /^#(?:[0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test(value.trim());
            }

            function applyMainParticleSettings(raw) {
                if (!raw || typeof raw !== 'object') return;

                const num = (v, fallback) => {
                    const n = Number(v);
                    return Number.isFinite(n) ? n : fallback;
                };
                const clamp01 = (v, fallback) => {
                    const n = num(v, fallback);
                    return Math.max(0, Math.min(1, n));
                };

                // Density keys from Particle Forge config
                if (raw.logoDensity != null || raw.density != null) {
                    CONFIG.particleCount = Math.max(1000, Math.round(num(raw.logoDensity ?? raw.density, CONFIG.particleCount)));
                }

                if (raw.size != null) CONFIG.particleSize = Math.max(0.1, num(raw.size, CONFIG.particleSize));
                if (raw.glowIntensity != null) CONFIG.glowIntensity = clamp01(raw.glowIntensity, CONFIG.glowIntensity);
                if (raw.depthVariance != null) CONFIG.depthVariance = Math.max(0, num(raw.depthVariance, CONFIG.depthVariance));
                if (raw.zoom != null) CONFIG.zoom = Math.max(0.1, num(raw.zoom, CONFIG.zoom));
                if (raw.sizeRandom != null) CONFIG.sizeRandom = clamp01(raw.sizeRandom, CONFIG.sizeRandom);
                if (raw.opacityRandom != null) CONFIG.opacityRandom = clamp01(raw.opacityRandom, CONFIG.opacityRandom);
                if (raw.sizeMin != null) CONFIG.sizeMin = Math.max(0.05, num(raw.sizeMin, CONFIG.sizeMin));
                if (raw.sizeMax != null) CONFIG.sizeMax = Math.max(0.05, num(raw.sizeMax, CONFIG.sizeMax));
                if (raw.opacityMin != null) CONFIG.opacityMin = clamp01(raw.opacityMin, CONFIG.opacityMin);
                if (raw.opacityMax != null) CONFIG.opacityMax = clamp01(raw.opacityMax, CONFIG.opacityMax);
                if (raw.squaresEnabled != null) CONFIG.squaresEnabled = !!raw.squaresEnabled;
                if (raw.squareRatio != null) CONFIG.squareRatio = clamp01(raw.squareRatio, CONFIG.squareRatio);
                if (raw.chromaticShift != null) CONFIG.chromaticShift = Math.max(0, num(raw.chromaticShift, CONFIG.chromaticShift));

                if (typeof raw.gradientOverlayEnabled === 'boolean') CONFIG.gradientOverlayEnabled = raw.gradientOverlayEnabled;
                if (isHexColor(raw.gradientColorA)) CONFIG.gradientColorA = raw.gradientColorA;
                if (isHexColor(raw.gradientColorB)) CONFIG.gradientColorB = raw.gradientColorB;
                if (raw.gradientStrength != null) CONFIG.gradientStrength = clamp01(raw.gradientStrength, CONFIG.gradientStrength);
                if (typeof raw.gradientDirection === 'string') CONFIG.gradientDirection = raw.gradientDirection;

                if (isHexColor(raw.particleColor)) CONFIG.particleColor = raw.particleColor;

                if (typeof raw.colorMode === 'string') {
                    const mode = raw.colorMode.trim();
                    if (isHexColor(mode)) {
                        // Particle Forge stores solid color choices in colorMode as hex.
                        CONFIG.particleColor = mode;
                    } else if (mode) {
                        CONFIG.colorMode = mode;
                    }
                }
            }

            async function loadMainSettingsFile() {
                try {
                    const res = await fetch('./particle-settings.json', { cache: 'no-store' });
                    if (!res.ok) return;
                    const json = await res.json();
                    applyMainParticleSettings(json);
                } catch (_err) {
                    // Optional file; keep defaults when unavailable.
                }
            }

            function applyResponsiveParticleCount() {
                if (window.matchMedia(PHONE_PARTICLE_QUERY).matches) {
                    CONFIG.particleCount = PHONE_PARTICLE_COUNT;
                    CONFIG.particleSize = PHONE_PARTICLE_SIZE;
                }
            }

            // Paging constants
            const LOGOS_PER_PAGE = 6;

            // State — global index tracks position across ALL logos
            let globalIndex = CONFIG.initialActive;
            let nextGlobalIndex = null;
            let currentPage = 0;
            let isPageTransitioning = false;

            let cycleTimer = null;
            let pauseTimer = null;
            let isPaused = false;
            let isTransitioning = false;
            let transitionStartTime = 0;

            // GPU Particle system components
            let gpuSim = null;
            let rasterSampler = null;
            let renderer = null;
            let gl = null;
            let targetTextures = [];
            let animationId = null;
            let lastTime = 0;

            // Logo data loaded from manifest
            let logoManifest = [];
            let svgStrings = [];

            // DOM Elements
            const hero = document.querySelector('.hero');
            const canvas = document.getElementById('particle-canvas');
            const logoGrid = document.querySelector('.logo-grid');
            const pageAnnounce = document.getElementById('page-announce');
            let cells = [];
            let totalLogos = 0;

            // Check for reduced motion preference
            const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

            // ── Paging helpers ──────────────────────────

            function totalPages() {
                return Math.ceil(totalLogos / LOGOS_PER_PAGE);
            }

            /** Which page does global index `gi` fall on? */
            function pageOf(gi) {
                return Math.floor(gi / LOGOS_PER_PAGE);
            }

            /** Which cell (0-5) within its page does `gi` map to? */
            function cellOf(gi) {
                return gi % LOGOS_PER_PAGE;
            }

            /** Global index from page + cell */
            function globalOf(page, cell) {
                return page * LOGOS_PER_PAGE + cell;
            }

            /** How many logos does page `p` show? Always 6 (wraps around manifest). */
            function logosOnPage(p) {
                return LOGOS_PER_PAGE;
            }

            /**
             * Find the next global index (starting at `startGi`) that has a valid GPU target texture.
             * Returns null when no usable textures exist.
             */
            function findNextRenderableGlobalIndex(startGi) {
                if (!totalLogos || !targetTextures.length) return null;

                for (let offset = 0; offset < totalLogos; offset++) {
                    const gi = startGi + offset;
                    const texIdx = ((gi % totalLogos) + totalLogos) % totalLogos;
                    if (targetTextures[texIdx]) return gi;
                }

                return null;
            }

            // ── Logo loading ────────────────────────────

            async function loadLogos() {
                const manifestRes = await fetch('assets/logos/logos.json');
                if (!manifestRes.ok) throw new Error(`Failed to load logo manifest (${manifestRes.status})`);
                const manifest = await manifestRes.json();
                logoManifest = manifest.logos;

                const activeIdx = logoManifest.findIndex(l => l.initialActive);
                if (activeIdx !== -1) {
                    CONFIG.initialActive = activeIdx;
                    globalIndex = activeIdx;
                }

                const fetches = logoManifest.map(logo =>
                    fetch(`assets/logos/${logo.file}`).then(r => {
                        if (!r.ok) throw new Error(`Failed to load ${logo.file}`);
                        return r.text();
                    })
                );
                svgStrings = await Promise.all(fetches);
                totalLogos = logoManifest.length;
            }

            function deduplicateSvgIds(svgString, prefix) {
                return svgString.replace(/\bid="([^"]+)"/g, `id="${prefix}_$1"`)
                                .replace(/url\(#([^)]+)\)/g, `url(#${prefix}_$1)`)
                                .replace(/#clip(\d)/g, `#${prefix}_clip$1`);
            }

            // ── Grid building (paged) ───────────────────

            /**
             * Build the logo grid for a specific page.
             * Always renders LOGOS_PER_PAGE cells; wraps around the manifest for partial pages.
             */
            function buildLogoGrid(page) {
                currentPage = page;
                logoGrid.innerHTML = '';

                const activeCellIdx = cellOf(globalIndex);

                for (let cell = 0; cell < LOGOS_PER_PAGE; cell++) {
                    const gi = globalOf(page, cell);
                    const wrappedIdx = gi % totalLogos;
                    const logo = logoManifest[wrappedIdx];
                    const isActive = (cell === activeCellIdx && pageOf(globalIndex) === page);

                    const btn = document.createElement('button');
                    btn.className = 'logo-cell' + (isActive ? ' logo-cell-active' : '');
                    btn.setAttribute('role', 'listitem');
                    btn.setAttribute('data-logo', logo.id);
                    btn.setAttribute('data-global-index', String(gi));
                    btn.setAttribute('aria-label', `View ${logo.name} logo`);
                    btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
                    btn.setAttribute('tabindex', '0');

                    let thumbSvg = deduplicateSvgIds(svgStrings[wrappedIdx], `logo_${logo.id}_p${page}_c${cell}`);
                    thumbSvg = thumbSvg.replace(/fill="#111111"/g, 'fill="currentColor"');

                    const wrapper = document.createElement('div');
                    wrapper.className = 'logo-wrapper';
                    wrapper.innerHTML = thumbSvg;

                    const svgEl = wrapper.querySelector('svg');
                    if (svgEl) {
                        svgEl.classList.add('logo-img');
                        svgEl.setAttribute('aria-hidden', 'true');
                    }

                    btn.appendChild(wrapper);
                    logoGrid.appendChild(btn);
                }

                cells = Array.from(logoGrid.querySelectorAll('.logo-cell'));

                cells.forEach(cell => {
                    cell.addEventListener('click', handleCellClick);
                    cell.addEventListener('keydown', handleKeyDown);
                });
            }

            // ── GPU particle system ─────────────────────

            async function initParticleSystem() {
                const container = canvas.parentElement;
                let rect = container.getBoundingClientRect();
                if (rect.width === 0 || rect.height === 0) {
                    await new Promise(resolve => requestAnimationFrame(resolve));
                    rect = container.getBoundingClientRect();
                }

                const dpr = Math.min(window.devicePixelRatio || 1, 2);
                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;

                renderer = new Renderer(canvas);
                if (!renderer.gl) {
                    console.error('WebGL2 not supported');
                    return;
                }

                gl = renderer.gl;

                renderer.settings.glowIntensity = CONFIG.glowIntensity;
                renderer.settings.depthVariance = CONFIG.depthVariance;
                renderer.settings.zoom = CONFIG.zoom;
                renderer.settings.userSize = CONFIG.particleSize;
                renderer.settings.useColorOverride = true;
                const hexToRgb = (hex) => {
                    const h = hex.replace('#', '');
                    return [
                        parseInt(h.substring(0, 2), 16) / 255,
                        parseInt(h.substring(2, 4), 16) / 255,
                        parseInt(h.substring(4, 6), 16) / 255
                    ];
                };
                renderer.settings.colorOverrideRgb = hexToRgb(CONFIG.particleColor);
                renderer.settings.sizeRandom = CONFIG.sizeRandom;
                renderer.settings.opacityRandom = CONFIG.opacityRandom;
                renderer.settings.sizeMin = CONFIG.sizeMin;
                renderer.settings.sizeMax = CONFIG.sizeMax;
                renderer.settings.opacityMin = CONFIG.opacityMin;
                renderer.settings.opacityMax = CONFIG.opacityMax;
                renderer.settings.squaresEnabled = CONFIG.squaresEnabled;
                renderer.settings.squareRatio = CONFIG.squareRatio;
                renderer.settings.colorMode = CONFIG.colorMode;
                renderer.settings.chromaticShift = CONFIG.chromaticShift;
                renderer.settings.gradientOverlayEnabled = CONFIG.gradientOverlayEnabled;
                renderer.settings.gradientColorA = CONFIG.gradientColorA;
                renderer.settings.gradientColorB = CONFIG.gradientColorB;
                renderer.settings.gradientStrength = CONFIG.gradientStrength;
                renderer.settings.gradientDirection = CONFIG.gradientDirection;

                try {
                    gpuSim = new GPUParticleSim(gl, { count: CONFIG.particleCount, seed: 42 });
                } catch (e) {
                    console.error('GPU particle sim not supported:', e);
                    return;
                }

                rasterSampler = new RasterPointSampler();

                for (const svgString of svgStrings) {
                    try {
                        const { texture } = await rasterSampler.sampleToTexture(
                            gl, svgString, CONFIG.particleCount,
                            { rasterSize: 1024, edgeRatio: 0.5 }
                        );
                        targetTextures.push(texture);
                    } catch (e) {
                        console.error('Failed to sample SVG to texture:', e);
                        targetTextures.push(null);
                    }
                }

                const initialGi = findNextRenderableGlobalIndex(globalIndex);
                if (initialGi !== null) {
                    globalIndex = initialGi;
                    nextGlobalIndex = null;

                    const initialTex = targetTextures[initialGi % totalLogos];
                    gpuSim.setTargets({ fromTex: initialTex, toTex: initialTex });
                    setActiveLogo(globalIndex, true);
                }

                window.addEventListener('resize', handleResize);
                startAnimationLoop();
            }

            function handleResize() {
                if (!canvas || !renderer) return;
                const container = canvas.parentElement;
                const rect = container.getBoundingClientRect();
                const dpr = Math.min(window.devicePixelRatio || 1, 2);
                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;
            }

            // ── Animation loop ──────────────────────────

            function startAnimationLoop() {
                lastTime = performance.now();

                function animate(currentTime) {
                    const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.05);
                    lastTime = currentTime;

                    let morphT = 1, scatterT = 0, chaosT = 0, attractT = 1, settleT = 1;

                    if (isTransitioning) {
                        const elapsed = currentTime - transitionStartTime;
                        const progress = Math.min(elapsed / CONFIG.morphDuration, 1);
                        const easedProgress = easeInOutCubic(progress);

                        morphT = easedProgress;
                        scatterT = Math.sin(progress * Math.PI) * 0.4;
                        chaosT = Math.sin(progress * Math.PI) * 0.6;
                        attractT = easedProgress;
                        settleT = progress * progress;

                        if (progress >= 1) {
                            const texIdx = nextGlobalIndex % totalLogos;
                            const toTex = targetTextures[texIdx];
                            if (toTex) {
                                gpuSim.setTargets({ fromTex: toTex, toTex: toTex });
                            }
                            globalIndex = nextGlobalIndex;
                            isTransitioning = false;
                        }
                    }

                    gpuSim.step(deltaTime, {
                        morphT, scatterT, chaosT, attractT, settleT,
                        noiseScale: 3.5, noiseStrength: 0.9, noiseSpeed: 0.2,
                        vortexStrength: 1.5, vortexRadius: 0.7,
                        vortex1: [0.0, 0.0], vortex2: [-0.25, 0.2], vortex3: [0.3, -0.15],
                        repulseStrength: 1.2, attractStrength: 2.8,
                        drag: 1.2, maxSpeed: 2.5
                    });

                    const curTexIdx = globalIndex % totalLogos;
                    const nextTexIdx = nextGlobalIndex !== null ? (nextGlobalIndex % totalLogos) : curTexIdx;

                    renderer.renderGPU({
                        count: gpuSim.count,
                        texWidth: gpuSim.texWidth,
                        texHeight: gpuSim.texHeight,
                        posTex: gpuSim.getPositionTexture(),
                        velTex: gpuSim.getVelocityTexture(),
                        randTex: gpuSim.getRandomTexture(),
                        targetFromTex: targetTextures[curTexIdx],
                        targetToTex: targetTextures[nextTexIdx]
                    });

                    animationId = requestAnimationFrame(animate);
                }

                animationId = requestAnimationFrame(animate);
            }

            function easeInOutCubic(t) {
                return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
            }

            // ── Morph & activation ──────────────────────

            function morphToLogo(gi) {
                const texIdx = gi % totalLogos;
                if (!gpuSim || !targetTextures[texIdx]) return;

                const fromTexIdx = globalIndex % totalLogos;
                const fromTex = targetTextures[fromTexIdx];
                const toTex = targetTextures[texIdx];

                if (fromTex && toTex) {
                    gpuSim.setTargets({ fromTex, toTex });
                }

                nextGlobalIndex = gi;
                isTransitioning = true;
                transitionStartTime = performance.now();
            }

            /**
             * Set active logo by global index.
             * Highlights the correct cell on the current page.
             */
            function setActiveLogo(gi, skipMorph = false) {
                const cellIdx = cellOf(gi);

                cells.forEach((cell, i) => {
                    const isActive = (i === cellIdx);
                    cell.classList.toggle('logo-cell-active', isActive);
                    cell.setAttribute('aria-pressed', isActive ? 'true' : 'false');
                });

                if (!skipMorph && gi !== globalIndex) {
                    morphToLogo(gi);
                } else if (skipMorph) {
                    globalIndex = gi;
                }
            }

            // ── Paging transitions ──────────────────────

            /**
             * Cycle to the next logo. If we've reached the end of the current page,
             * trigger a page transition instead.
             */
            function cycleToNext() {
                if (isPaused || isTransitioning || isPageTransitioning) return;

                const nextGi = findNextRenderableGlobalIndex(globalIndex + 1);
                if (nextGi === null || nextGi === globalIndex) return;

                const nextPage = pageOf(nextGi);

                if (nextPage !== currentPage) {
                    // We've cycled through all cells on this page — transition to next page
                    const destinationPage = nextPage % totalPages();
                    transitionToPage(destinationPage);
                } else {
                    setActiveLogo(nextGi);
                }
            }

            /**
             * Simultaneous crossfade using a body-level clone.
             * The clone is placed in document.body with position:fixed so it is
             * completely isolated from .logo-grid's CSS cascade and layout.
             */
            function transitionToPage(newPage) {
                isPageTransitioning = true;
                stopCycling();
                logoGrid.setAttribute('aria-busy', 'true');

                const transitionMs = prefersReducedMotion ? 10 : 1000;

                // Step 1: Snapshot the grid's viewport position
                const rect = logoGrid.getBoundingClientRect();

                // Step 2: Deep-clone the grid and restyle as a fixed overlay
                const clone = logoGrid.cloneNode(true);
                clone.className = 'crossfade-clone';
                clone.removeAttribute('role');
                clone.removeAttribute('aria-label');
                clone.setAttribute('aria-hidden', 'true');
                clone.style.top = rect.top + 'px';
                clone.style.left = rect.left + 'px';
                clone.style.width = rect.width + 'px';
                clone.style.height = rect.height + 'px';
                // Step 3: Append clone to body (completely outside .logo-grid)
                document.body.appendChild(clone);

                // Step 4: Rebuild the real grid with new page content
                const firstGi = globalOf(newPage, 0);
                buildLogoGrid(newPage);

                // Step 5: Set new grid cells to hidden (blur-in start state)
                logoGrid.classList.add('page-enter');

                // Force reflow so browser registers initial hidden state
                void logoGrid.offsetHeight;

                // Step 6: Simultaneously fade out clone + blur in new grid
                logoGrid.classList.remove('page-enter');
                logoGrid.classList.add('page-enter-active');
                clone.classList.add('fade-out');

                // Step 7: Cleanup after transition completes
                setTimeout(() => {
                    logoGrid.classList.remove('page-enter-active');
                    if (clone.parentNode) clone.parentNode.removeChild(clone);
                    logoGrid.setAttribute('aria-busy', 'false');
                    isPageTransitioning = false;

                    // Morph particles to the first logo on the new page
                    setActiveLogo(firstGi);

                    // Announce page change for screen readers
                    const pageNum = newPage + 1;
                    const firstName = logoManifest[firstGi % totalLogos].name;
                    pageAnnounce.textContent = `Page ${pageNum} of ${totalPages()}, showing ${firstName}`;

                    // Resume auto-cycling
                    if (!isPaused) {
                        startCycling();
                    }
                }, transitionMs);
            }

            // ── Cycling controls ────────────────────────

            function startCycling() {
                if (prefersReducedMotion) return;
                stopCycling();
                cycleTimer = setInterval(cycleToNext, CONFIG.cycleInterval);
            }

            function stopCycling() {
                if (cycleTimer) {
                    clearInterval(cycleTimer);
                    cycleTimer = null;
                }
            }

            function pauseCycling() {
                isPaused = true;
                stopCycling();

                if (pauseTimer) clearTimeout(pauseTimer);
                pauseTimer = setTimeout(() => {
                    isPaused = false;
                    startCycling();
                }, CONFIG.pauseDuration);
            }

            // ── Event handlers ──────────────────────────

            function handleCellClick(event) {
                if (isPageTransitioning) return;
                const cell = event.currentTarget;
                const gi = parseInt(cell.getAttribute('data-global-index'), 10);

                if (!isNaN(gi) && gi !== globalIndex && !isTransitioning) {
                    setActiveLogo(gi);
                    pauseCycling();
                }
            }

            function handleKeyDown(event) {
                if (isPageTransitioning) return;
                const cell = event.currentTarget;
                const cellIdx = Array.from(cells).indexOf(cell);
                let newCellIdx = cellIdx;

                switch (event.key) {
                    case 'Enter':
                    case ' ': {
                        event.preventDefault();
                        const gi = parseInt(cell.getAttribute('data-global-index'), 10);
                        if (!isNaN(gi) && gi !== globalIndex && !isTransitioning) {
                            setActiveLogo(gi);
                            pauseCycling();
                        }
                        break;
                    }
                    case 'ArrowRight':
                        event.preventDefault();
                        newCellIdx = (cellIdx + 1) % LOGOS_PER_PAGE;
                        cells[newCellIdx].focus();
                        break;
                    case 'ArrowLeft':
                        event.preventDefault();
                        newCellIdx = (cellIdx - 1 + LOGOS_PER_PAGE) % LOGOS_PER_PAGE;
                        cells[newCellIdx].focus();
                        break;
                    case 'ArrowDown':
                        event.preventDefault();
                        newCellIdx = (cellIdx + 3) % LOGOS_PER_PAGE;
                        cells[newCellIdx].focus();
                        break;
                    case 'ArrowUp':
                        event.preventDefault();
                        newCellIdx = (cellIdx - 3 + LOGOS_PER_PAGE) % LOGOS_PER_PAGE;
                        cells[newCellIdx].focus();
                        break;
                }
            }

            // ── Splash screen orchestration ─────────────

            const splash = document.querySelector('.splash-screen');
            const splashAlreadyShown = sessionStorage.getItem('splashShown') === '1';

            function runSplashSequence() {
                return new Promise(resolve => {
                    setTimeout(() => { splash.classList.add('splash-appear'); }, 300);
                    setTimeout(() => { splash.classList.add('splash-fade'); }, 3000);
                    setTimeout(() => { splash.classList.add('splash-bg-black'); }, 3600);
                    setTimeout(() => { splash.style.display = 'none'; resolve(); }, 4100);
                });
            }

            // ── Initialization ──────────────────────────

            await loadMainSettingsFile();
            applyResponsiveParticleCount();
            await loadLogos();
            currentPage = pageOf(globalIndex);
            buildLogoGrid(currentPage);
            setActiveLogo(globalIndex, true);

            if (splashAlreadyShown) {
                splash.style.display = 'none';
                hero.classList.add('instant');
                await initParticleSystem();
                requestAnimationFrame(() => { hero.classList.add('loaded'); });
            } else {
                await Promise.all([
                    runSplashSequence(),
                    initParticleSystem()
                ]);
                sessionStorage.setItem('splashShown', '1');
                requestAnimationFrame(() => { hero.classList.add('loaded'); });
            }

            if (!prefersReducedMotion) {
                setTimeout(() => {
                    cycleToNext();
                    if (!isPaused && !isPageTransitioning) {
                        startCycling();
                    }
                }, CONFIG.initialDelay);
            }

            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    stopCycling();
                    if (animationId) {
                        cancelAnimationFrame(animationId);
                        animationId = null;
                    }
                } else {
                    if (!animationId) {
                        startAnimationLoop();
                    }
                    if (!isPaused && !isPageTransitioning) {
                        startCycling();
                    }
                }
            });
        })();
    </script>
</body>
</html>
